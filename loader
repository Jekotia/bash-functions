#! /bin/bash

#-> PRIMARY FUNCTION FILE LOADER. LOADS ALL FILES ENDING IN .sh UNDER THE PATH PROVIDED, TO ANY DEPTH
#-> TAKES ONE STRING ARG AS FUNCTION PATH
function loader() {
	debug "BEGIN loader"
	debug

	#-> SET VARIABLE CONTAINING PATH TO SOURCE FROM
	local FUNC_PATH="${@}"
	#-> DETERMINE MAXIMUM DEPTH OF $FUNC_PATH DIRECTORY TREE
	local max_depth=$(find ${FUNC_PATH} -type d -printf '%d\n' | sort -rn | head -1)
	#-> INCREMENT MAX DEPTH BY ONE, SINCE IT COMES UP SHORT FOR OUR PURPOSES
	((max_depth++))
	#-> SET VARIABLE FOR TRACKING CURRENT DEPTH
	local depth=0
	#-> SET VERIABLE FOR BUILDING DEPTH-BASED PATH TO SOURCE FROM
	local depth_str=""

	#-> WHILE CURRENT DEPTH IS BELOW MAX DEPTH, DO STUFF
	while [ ${depth} -lt ${max_depth} ] ; do
		debug "Sourcing at depth ${depth} in directory ${FUNC_PATH}${depth_str}"

		#-> LOOP FOR EACH FILE AT THE PATH EXPRESSED BY $SOURCE_PATH
		for f in ${FUNC_PATH}${depth_str}*.sh ; do
			#-> VERIFY THAT THERE ARE .sh FILES AT THIS LEVEL TO AVOID ERRORS
			#-> IF THERE ARE, CONTINUE SOURCING. IF NOT, CONTINUE BUT DO NOTHING
			files=$(shopt -s nullglob dotglob; echo ${FUNC_PATH}${depth_str}*.sh)
			if (( ${#files} )) ; then
				source $f
				errcode=$?
				if [ ${errcode} -ne 0 ] ; then
					debug "Failed to source $f"
				else
					debug "Sourced file: $f"
				fi
			else
				debug "empty (or does not exist, or is not a .sh file)"
			fi
		done

		#-> INCREASE THE DEPTH EXPRESSED
		depth_str=${depth_str}*/
		((depth++))
		debug
	done

	debug "END loader"
	debug
}
